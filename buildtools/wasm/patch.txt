diff --git a/internal/cparser/include/access/xlogdefs.h b/internal/cparser/include/access/xlogdefs.h
index a47e3ee..fc5925a 100644
--- a/internal/cparser/include/access/xlogdefs.h
+++ b/internal/cparser/include/access/xlogdefs.h
@@ -78,10 +78,7 @@ typedef uint16 RepOriginId;
 
 #if defined(O_DSYNC)
 #if defined(OPEN_SYNC_FLAG)
-/* O_DSYNC is distinct? */
-#if O_DSYNC != OPEN_SYNC_FLAG
 #define OPEN_DATASYNC_FLAG		O_DSYNC
-#endif
 #else							/* !defined(OPEN_SYNC_FLAG) */
 /* Win32 only has O_DSYNC */
 #define OPEN_DATASYNC_FLAG		O_DSYNC
diff --git a/internal/cparser/include/utils/elog.h b/internal/cparser/include/utils/elog.h
index 9cfad3d..efc3057 100644
--- a/internal/cparser/include/utils/elog.h
+++ b/internal/cparser/include/utils/elog.h
@@ -312,13 +312,13 @@ extern PGDLLIMPORT __thread  ErrorContextCallback *error_context_stack;
  */
 #define PG_TRY()  \
 	do { \
-		sigjmp_buf *_save_exception_stack = PG_exception_stack; \
+		jmp_buf *_save_exception_stack = PG_exception_stack; \
 		ErrorContextCallback *_save_context_stack = error_context_stack; \
-		sigjmp_buf _local_sigjmp_buf; \
+		jmp_buf _local_jmp_buf; \
 		bool _do_rethrow = false; \
-		if (sigsetjmp(_local_sigjmp_buf, 0) == 0) \
+		if (setjmp(_local_jmp_buf) == 0) \
 		{ \
-			PG_exception_stack = &_local_sigjmp_buf
+			PG_exception_stack = &_local_jmp_buf
 
 #define PG_CATCH()	\
 		} \
@@ -355,7 +355,7 @@ extern PGDLLIMPORT __thread  ErrorContextCallback *error_context_stack;
 	(pg_re_throw(), pg_unreachable())
 #endif
 
-extern PGDLLIMPORT __thread  sigjmp_buf *PG_exception_stack;
+extern PGDLLIMPORT __thread  jmp_buf *PG_exception_stack;
 
 
 /* Stuff that error handlers might want to use */
diff --git a/internal/cparser/pg_query.c b/internal/cparser/pg_query.c
index e0069e8..8465a66 100644
--- a/internal/cparser/pg_query.c
+++ b/internal/cparser/pg_query.c
@@ -5,14 +5,10 @@
 #include <utils/memutils.h>
 #include <utils/memdebug.h>
 
-#include <pthread.h>
-#include <signal.h>
-
 const char* progname = "pg_query";
 
-__thread sig_atomic_t pg_query_initialized = 0;
+__thread int pg_query_initialized = 0;
 
-static pthread_key_t pg_query_thread_exit_key;
 static void pg_query_thread_exit(void *key);
 
 void pg_query_init(void)
@@ -22,9 +18,6 @@ void pg_query_init(void)
 
 	MemoryContextInit();
 	SetDatabaseEncoding(PG_UTF8);
-
-	pthread_key_create(&pg_query_thread_exit_key, pg_query_thread_exit);
-	pthread_setspecific(pg_query_thread_exit_key, TopMemoryContext);
 }
 
 void pg_query_free_top_memory_context(MemoryContext context)
diff --git a/internal/cparser/src_backend_utils_error_elog.c b/internal/cparser/src_backend_utils_error_elog.c
index 6dfd560..1330e5b 100644
--- a/internal/cparser/src_backend_utils_error_elog.c
+++ b/internal/cparser/src_backend_utils_error_elog.c
@@ -1444,7 +1444,7 @@ pg_re_throw(void)
 {
 	/* If possible, throw the error to the next outer setjmp handler */
 	if (PG_exception_stack != NULL)
-		siglongjmp(*PG_exception_stack, 1);
+		longjmp(*PG_exception_stack, 1);
 	else
 	{
 		/*
diff --git a/internal/cparser/src_port_strerror.c b/internal/cparser/src_port_strerror.c
index 45686d3..171eea8 100644
--- a/internal/cparser/src_port_strerror.c
+++ b/internal/cparser/src_port_strerror.c
@@ -160,8 +160,6 @@ get_errno_symbol(int errnum)
 			return "EFAULT";
 		case EFBIG:
 			return "EFBIG";
-		case EHOSTDOWN:
-			return "EHOSTDOWN";
 		case EHOSTUNREACH:
 			return "EHOSTUNREACH";
 		case EIDRM:
diff --git a/internal/cparser/include/pg_config.h b/internal/cparser/include/pg_config.h
index 59a2288..d1d5cb0 100644
--- a/internal/cparser/include/pg_config.h
+++ b/internal/cparser/include/pg_config.h
@@ -1036,3 +1036,10 @@
 #if defined(__FreeBSD__) || defined(__NetBSD__) || (defined(__GLIBC__) && ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 38) || __GLIBC__ > 2))
 #define HAVE_STRCHRNUL
 #endif
+
+#undef SIZEOF_OFF_T
+#define SIZEOF_OFF_T 4
+#undef SIZEOF_SIZE_T
+#define SIZEOF_SIZE_T 4
+#undef SIZEOF_VOID_P
+#define SIZEOF_VOID_P 4
diff --git a/internal/cparser/src_port_pg_bitutils.c b/internal/cparser/src_port_pg_bitutils.c
index 6889b8a..b7b4895 100644
--- a/internal/cparser/src_port_pg_bitutils.c
+++ b/internal/cparser/src_port_pg_bitutils.c
@@ -175,9 +175,23 @@ __asm__ __volatile__(" popcntq %1,%0\n":"=q"(res):"rm"(word):"cc");
  * pg_popcount32_slow
  *		Return the number of 1 bits set in word
  */
+static int
+pg_popcount32_slow(uint32 word)
+{
 #ifdef HAVE__BUILTIN_POPCOUNT
-#else							/* !HAVE__BUILTIN_POPCOUNT */
-#endif							/* HAVE__BUILTIN_POPCOUNT */
+	return __builtin_popcount(word);
+#else                           /* !HAVE__BUILTIN_POPCOUNT */
+	int         result = 0;
+
+	while (word != 0)
+	{
+		result += pg_number_of_ones[word & 255];
+		word >>= 8;
+	}
+
+	return result;
+#endif                          /* HAVE__BUILTIN_POPCOUNT */
+}
 
 /*
  * pg_popcount64_slow
@@ -216,7 +230,11 @@ pg_popcount64_slow(uint64 word)
  * TRY_POPCNT_FAST is not defined.  The compiler should be able to inline
  * the slow versions here.
  */
-
+ int
+pg_popcount32(uint32 word)
+{
+	return pg_popcount32_slow(word);
+}
 
 int
 pg_popcount64(uint64 word)
