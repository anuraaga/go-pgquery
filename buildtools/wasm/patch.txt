diff --git a/internal/cparser/include/utils/elog.h b/internal/cparser/include/utils/elog.h
index 6acc2c2..552752e 100644
--- a/internal/cparser/include/utils/elog.h
+++ b/internal/cparser/include/utils/elog.h
@@ -383,13 +383,13 @@ extern PGDLLIMPORT __thread  ErrorContextCallback *error_context_stack;
  */
 #define PG_TRY(...)  \
 	do { \
-		sigjmp_buf *_save_exception_stack##__VA_ARGS__ = PG_exception_stack; \
+		jmp_buf *_save_exception_stack##__VA_ARGS__ = PG_exception_stack; \
 		ErrorContextCallback *_save_context_stack##__VA_ARGS__ = error_context_stack; \
-		sigjmp_buf _local_sigjmp_buf##__VA_ARGS__; \
+		jmp_buf _local_jmp_buf##__VA_ARGS__; \
 		bool _do_rethrow##__VA_ARGS__ = false; \
-		if (sigsetjmp(_local_sigjmp_buf##__VA_ARGS__, 0) == 0) \
+		if (setjmp(_local_jmp_buf##__VA_ARGS__) == 0) \
 		{ \
-			PG_exception_stack = &_local_sigjmp_buf##__VA_ARGS__
+			PG_exception_stack = &_local_jmp_buf##__VA_ARGS__
 
 #define PG_CATCH(...)	\
 		} \
@@ -426,7 +426,7 @@ extern PGDLLIMPORT __thread  ErrorContextCallback *error_context_stack;
 	(pg_re_throw(), pg_unreachable())
 #endif
 
-extern PGDLLIMPORT __thread  sigjmp_buf *PG_exception_stack;
+extern PGDLLIMPORT __thread  jmp_buf *PG_exception_stack;
 
 
 /* Stuff that error handlers might want to use */
diff --git a/internal/cparser/pg_query.c b/internal/cparser/pg_query.c
index e0069e8..8465a66 100644
--- a/internal/cparser/pg_query.c
+++ b/internal/cparser/pg_query.c
@@ -5,14 +5,10 @@
 #include <utils/memutils.h>
 #include <utils/memdebug.h>
 
-#include <pthread.h>
-#include <signal.h>
-
 const char* progname = "pg_query";
 
-__thread sig_atomic_t pg_query_initialized = 0;
+__thread int pg_query_initialized = 0;
 
-static pthread_key_t pg_query_thread_exit_key;
 static void pg_query_thread_exit(void *key);
 
 void pg_query_init(void)
@@ -22,9 +18,6 @@ void pg_query_init(void)
 
 	MemoryContextInit();
 	SetDatabaseEncoding(PG_UTF8);
-
-	pthread_key_create(&pg_query_thread_exit_key, pg_query_thread_exit);
-	pthread_setspecific(pg_query_thread_exit_key, TopMemoryContext);
 }
 
 void pg_query_free_top_memory_context(MemoryContext context)
diff --git a/internal/cparser/src_backend_utils_error_elog.c b/internal/cparser/src_backend_utils_error_elog.c
index 6dfd560..1330e5b 100644
--- a/internal/cparser/src_backend_utils_error_elog.c
+++ b/internal/cparser/src_backend_utils_error_elog.c
@@ -1444,7 +1444,7 @@ pg_re_throw(void)
 {
 	/* If possible, throw the error to the next outer setjmp handler */
 	if (PG_exception_stack != NULL)
-		siglongjmp(*PG_exception_stack, 1);
+		longjmp(*PG_exception_stack, 1);
 	else
 	{
 		/*
diff --git a/internal/cparser/src_port_strerror.c b/internal/cparser/src_port_strerror.c
index 45686d3..171eea8 100644
--- a/internal/cparser/src_port_strerror.c
+++ b/internal/cparser/src_port_strerror.c
@@ -160,8 +160,6 @@ get_errno_symbol(int errnum)
 			return "EFAULT";
 		case EFBIG:
 			return "EFBIG";
-		case EHOSTDOWN:
-			return "EHOSTDOWN";
 		case EHOSTUNREACH:
 			return "EHOSTUNREACH";
 		case EIDRM:
diff --git a/internal/cparser/src_port_pg_bitutils.c b/internal/cparser/src_port_pg_bitutils.c
index aa6514a..3539489 100644
--- a/internal/cparser/src_port_pg_bitutils.c
+++ b/internal/cparser/src_port_pg_bitutils.c
@@ -175,9 +175,23 @@ __asm__ __volatile__(" popcntq %1,%0\n":"=q"(res):"rm"(word):"cc");
  * pg_popcount32_slow
  *		Return the number of 1 bits set in word
  */
+ static int
+pg_popcount32_slow(uint32 word)
+{
 #ifdef HAVE__BUILTIN_POPCOUNT
-#else							/* !HAVE__BUILTIN_POPCOUNT */
-#endif							/* HAVE__BUILTIN_POPCOUNT */
+	return __builtin_popcount(word);
+#else                           /* !HAVE__BUILTIN_POPCOUNT */
+	int         result = 0;
+
+	while (word != 0)
+	{
+		result += pg_number_of_ones[word & 255];
+		word >>= 8;
+	}
+
+	return result;
+#endif                          /* HAVE__BUILTIN_POPCOUNT */
+}
 
 /*
  * pg_popcount64_slow
@@ -216,7 +230,11 @@ pg_popcount64_slow(uint64 word)
  * TRY_POPCNT_FAST is not defined.  The compiler should be able to inline
  * the slow versions here.
  */
-
+int
+pg_popcount32(uint32 word)
+{
+	return pg_popcount32_slow(word);
+}
 
 int
 pg_popcount64(uint64 word)
